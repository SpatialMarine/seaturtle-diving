#Script to process low resolution dives Part 2. (based on D. March turtle dataset). Jessica Harvey-Carroll (carrolljessh@gmail.com/ jessica.carroll@bioenv.gu.se). 2023#

# Retrieving dive summaries and subsetting dives of low resolution consists of the following steps:

#1. Relabel all data (from previous script)
#2. Compile final dives
#3. Extract dive summaries
#4. Load and bind all files together for HMM input

input_data <- paste0(input_dir, "/tracking/")
output_data <- paste0(output_dir, "/TTDR")
metadata <- read.csv(paste0(input_dir, "/tracking/TODB_2023-12-09_diveAnalysis.csv"))

for (i in 1:nrow(metadata)){
organismID <- metadata$ptt[i]
################################################################################
#------------------------------------------------------------------------------#
# Step 1. Relabel all data#
#------------------------------------------------------------------------------#
################################################################################
proc_data<- read.csv(paste0(output_data, "final_forprocess_", organismID, ".csv"))

proc_data$date <- as.POSIXct(proc_data$date,origin="1970-01-01",tz="UTC")
proc_data<-proc_data[order(proc_data$date),]

#leave datetime and depth

proc_data<-subset(proc_data, select = c(date,depth))

#reprocess
#rounded 5 in phases function
proc_dataPhase<-phases(proc_data)

#add in depth, time and speed diff from previous value

proc_dataPhase<-depth.diff(proc_dataPhase)
proc_dataPhase<-time.diff(proc_dataPhase)  
proc_dataPhase<-speed(proc_dataPhase)

#identify and label changes in direction, negative = decrease in depth
direc<-proc_dataPhase %>%
  mutate(direction = case_when(diff > 0 ~ 'positive',
                               diff < 0 ~ 'negative',
                               diff == 0 ~ 'no change',
                               TRUE ~ ''))
#remove duplicates
direc<-direc[!duplicated(direc), ]

#take surface readings
surfReads <- direc[is.na(direc$diveno),]

surfReads$organismID<-organismID

surfReads$date<-as.numeric(surfReads$date)

#save for future ref.
surface_complete_file <- paste0(output_data, "surfaceReadings_", organismID, ".csv")
write.csv(surfReads, surface_complete_file)

################################################################################
#==============================================================================#
# Step 2. Compile final dives###
#==============================================================================#
################################################################################
#add depth errors to dataframe

#merge with depth error
depthTempError_file <- paste0(output_data, "depthError", organismID, ".csv")
tempData<-read.csv(depthTempError_file)

tempData$date <- as.POSIXct(tempData$date,origin="1970-01-01",tz="UTC") 

compDives<-tempData %>% select(date, depthUpperError, depthLowerError)

compDivesMerge<- merge(direc, compDives, by="date", all.x = TRUE) 

compDivesMerge<-compDivesMerge[order(compDivesMerge$date),]

#split dives by number
data_sep<-split(compDivesMerge, compDivesMerge$diveno)

#find total number of dives
lastDive<-tail((names(data_sep)), n=1)
divNum<-as.numeric(lastDive[1])

#print names of all dives
names<-sprintf("dive%d", 1:divNum) 

split_names <- as.character(names)

#make each dive a seperate dataframe
for (i in 1:length(data_sep)) {        # Run for-loop
  assign(split_names[i], data_sep[[i]])
}

last.dive.name<-tail(names, n=1)
last.dive<-eval(parse(text = paste0(last.dive.name)))
if(tail(last.dive$depth,n=1)>=customDive_threshold){
  names<-names[1:length(names)-1]
}

#for loop for each dive and get summary statistic
#did have phase lab function here, but already run previously
#apply to all dives
for(i in  1:length(names)){
  data =  eval(parse(text = paste0( names[i])))
  assign(paste(names[i],"phase",sep = "_"), t<-dive.phaselab(data))
  print(paste(names[i],"phase",sep = "_"))
}

##new data frame with all dives
dive_list = mget(ls(pattern = "_phase"))
dives_complete = do.call(what = rbind, args = dive_list)
dives_complete<-dives_complete[order(dives_complete$date),]

dives_complete$organismID<-organismID
dives_complete$date<-as.numeric(dives_complete$date)
dives_complete_file <- paste0(output_data, "processed_dives_", organismID, ".csv")
write.csv(dives_complete, dives_complete_file)
################################################################################
###----------------------------------------------------------------------------#
### Step 3. Extract dive summaries #
###----------------------------------------------------------------------------#
################################################################################
#dive_summary function to extract dive summaries from individual dives

final<- paste(names, "phase", sep = "_")

#apply to all dives

for(i in  1:length(final)){
  data =  eval(parse(text = paste0( final[i])))
  assign(paste(final[i],"final",sep = "_"), t<-dive_summary(data))
  print(paste(final[i],"final",sep = "_"))
}
final2<- paste(final, "final", sep = "_")

fin_list = mget(ls(pattern = "_phase_final"))
dive_summaries = do.call(what = rbind, args = fin_list)
dive_summaries<-dive_summaries[order(dive_summaries$diveStartTime),]


dive_summaries$diveID <- c(1:nrow(dive_summaries))

dive_summaries$first48Hrs<- ifelse(as.Date(dive_summaries$diveStartTime) <= (as.Date(depl)+days(1)),
                                   "flag", "NA")

#replace id with turtleID
dive_summaries$organismID<-organismID
dive_summaries$concatID<-paste0(organismID,"_",dive_summaries$diveID)

#surf.time  function to calculate surface period following a dive
dive_summaries<-surf.time(dive_summaries)
colnames(dive_summaries)[colnames(dive_summaries) == "tim3"] ="surface_int"

#########check if depthNA is within surface interval################

diveEndTime = rep(NA,nrow(dive_summaries)-1)
nextdiveStartTime= rep(NA,nrow(dive_summaries)-1)
diveID= rep(NA,nrow(dive_summaries)-1)

surfNA<-as.data.frame(cbind(diveEndTime,nextdiveStartTime,diveID))

for(i in 1:nrow(dive_summaries)-1){
  a = dive_summaries$diveEndTime[i]
  b = dive_summaries$diveStartTime[i +1]
  # 
  # a = dive_summaries$diveStartTime[i]
  # b = dive_summaries$diveEndTime[i - 1]
  c= dive_summaries$diveID [i]
  
  surfNA[i,1]<-as.POSIXct(a,format="%Y-%m-%d %H:%M:%S",tz="UTC") 
  surfNA[i,2]<-as.POSIXct(b,format="%Y-%m-%d %H:%M:%S",tz="UTC") 
  surfNA[i,3]=c 
  
  
}
surfNA[,1]<-as.POSIXct(surfNA[,1], origin = "1970-01-01")
surfNA[,2]<-as.POSIXct(surfNA[,2], origin = "1970-01-01")

#depthNA[1,]<-as.POSIXct("2023-05-08 18:10:00", format="%Y-%m-%d %H:%M:%S")

#make sure all in same timezones
surfNA$diveEndTime<-force_tz(surfNA$diveEndTime, "UTC")
surfNA$nextdiveStartTime<-force_tz(surfNA$nextdiveStartTime, "UTC")

#depthNA is times with missing depths from first step
depthNA$date<-force_tz(depthNA$date, "UTC")

#find dives where depth NA's present
df1<-  surfNA
df2<- depthNA

setDT(df1); setDT(df2)
# initialise new column with "N"
df1[, dateoccurs := "N"]

#update join#
hasNA<-  df1[df2, dateoccurs := "Y", on = .(diveEndTime <= date, nextdiveStartTime >= date)][]
hasNA<-as.data.frame(hasNA)


dive_summaries <- merge(dive_summaries, hasNA, by = "diveID", 
                        all.x = TRUE) 

dive_summaries<-subset(dive_summaries, select=-c(diveEndTime.y, nextdiveStartTime))
colnames(dive_summaries)[colnames(dive_summaries) == "dateoccurs"] ="NaSurfaceInt"

dive_summaries_file <- paste0(output_data, "dive_summarys_", organismID, ".csv")
write.csv(dive_summaries, dive_summaries_file)


#import depth temp errors
depthTempError_file <- paste0(output_data, "depthError", organismID, ".csv")
tempData<-read.csv(depthTempError_file)

#extract dive and surface dpeths from final processed TTDR
diveTTDRProc<-subset(dives_complete, select = c(date,depth, diveno, organismID))
surfTTDRProc<-subset(surfReads, select = c(date,depth, diveno, organismID))

#merge together for final dataset for processing
diveSurfBind_final <- rbind(diveTTDRProc, surfTTDRProc)
diveSurfBindfinal_ord<-diveSurfBind_final[order(diveSurfBind_final$date),]

mergedTTDRProc<- merge(diveSurfBindfinal_ord, tempData, by="date", all.x = TRUE) 

# #now have fully processed TTDR with appended temp and depth errors
#calculate SST

sst<-getSST(mergedTTDRProc)
  
### Interpolate SST to TimeSeries
mergedTTDRProc$sst <- approx(x = sst$date, y = sst$temperature, xout = mergedTTDRProc$date, method="linear", rule=2)$y
mergedTTDRProc$sst <- round(mergedTTDRProc$sst, digits=1)
mergedTTDRProc$sst_qc <- 8  # interpolated data
mergedTTDRProc$sst_qc[mergedTTDRProc$date %in% sst$date] <- 1  # good data, no interpolated

#-------------------------------
# Temperature above SST test
#-------------------------------
### This test identifies temperature records that are above the estimated SST, given a temperature threshold
### We define a temperature threshold of 2 degrees
### We do not select points on the surface because there may be no depth available when having temperature data
### 4: bad data; 1: good data
mergedTTDRProc$aboveSST <- aboveSST(temp = mergedTTDRProc$temperature, temp.er = mergedTTDRProc$temperatureError,
                          sst = mergedTTDRProc$sst, temp.thr = 2)


mergedTTDRProc$aboveSST<-na.locf(mergedTTDRProc$aboveSST,na.rm = FALSE)
mergedTTDRProc = mergedTTDRProc[!duplicated(mergedTTDRProc$diveStartTime),]

names(dive_summaries)[names(dive_summaries) == "diveStartTime"] <- "date"

finalDiveSummaries<-merge(dive_summaries, mergedTTDRProc, by="date") 

finalDiveSummaries<-finalDiveSummaries[,c(1:21, 30:36)]
names(dive_summaries)[names(dive_summaries) == "date"] <- "diveStartTime"
dive_summariesSST_file <- paste0(output_data, "dive_summarysSST_", organismID, ".csv")
write.csv(finalDiveSummaries, dive_summariesSST_file)

#clean environment from previous loop iteration
rm(list=setdiff(ls(), c("output_data","input_data","metadata", "i")))

}
